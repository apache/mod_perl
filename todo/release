##################################################
# Things to be resolved for mod_perl 2.0 release #
##################################################

-- see also todo/api_status

* there was a report about PerlRun leaking memory. the reporter didn't
  give any more details, but I suspect that it's due to
  ModPerl::Util::unload_package() which perfectly fits the timing when
  the leak was introduced (when PerlRun started to use unload_package).

* we need to deal with a situation where an object is used to
  construct another object, but it's then auto-DESTROYed by perl
  rendering the object that used it corrupted.

  the solution is to make the newly created objects refer to the
  underlying object via magic attachment.

  only objects using objects that have DESTROY are effected, so for
  example in the case of:

  APR::Bucket::eos_create(APR::Bucket::alloc_create(APR::Pool->new)

  the object returned by eos_create shouldn't be affected, since
  alloc_create()'s object doesn't have perl's DESTROY. so only the
  pool object is an issue here (i.e. alloc_create needs special
  handling)

  relevant objects with DESTROY : Apache::SubRequest,
  APR::ThreadMutex, APR::UUID, APR::Pool


  =================
  === APR::Pool ===
  =================
  *** returning objects ***

  APR::Bucket:
  V apr_bucket_alloc_create
  ? mpxs_APR__Bucket_setaside
        (the wrapper is done, but the test is not reproducing the
        problem, but this seems to be a problem in
        modperl_bucket_sv_setaside which loses the newly seta-aside
        bucket)
  
  APR::Pool:
  ? mpxs_apr_pool_create (having problems): APR__Pool.patch
  
  Apache::RequestUtil:
  ? mpxs_Apache__RequestRec_new (having problems): Apache__RequestUtil.patch

